<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Bedtime Story Generator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f0f4f8;
    }
    h1 { text-align: center; color: #333; }
    .input-container { margin-bottom: 20px; }
    #prompt {
      width: 100%;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }
    .button-container {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 5px;
      background-color: #4CAF50;
      color: white;
    }
    button:hover { background-color: #45a049; }
    #random-btn { background-color: #008CBA; }
    #random-btn:hover { background-color: #007399; }
    #story {
      background-color: white;
      padding: 20px;
      border-radius: 5px;
      border: 1px solid #ddd;
      min-height: 100px;
    }
    #loading { display: none; text-align: center; color: #666; }
  </style>
</head>
<body>
  <h1>Bedtime Story Generator</h1>
  <div class="input-container">
    <input type="text" id="prompt"
           placeholder="Enter a story prompt (e.g., 'A brave kitten in a magical forest')">
  </div>
  <div class="button-container">
    <button onclick="generateStory()">Generate Story</button>
    <button id="random-btn" onclick="generateRandomStory()">Random Story</button>
  </div>
  <div id="loading">Generating story...</div>
  <div id="story"></div>

  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.min.js"></script>
  <script>
    let session = null;

    async function initModel() {
      try {
        session = await ort.InferenceSession.create(
          './models/TinyStories-Instruct-1M/TinyStories-Instruct-1M.onnx',
          { executionProviders: ['wasm'] }
        );
        console.log('Model loaded; inputs =', session.inputNames);
      } catch (e) {
        console.error('Failed to load model:', e);
        document.getElementById('story').innerHTML =
          '<p>Error loading model. Check console.</p>';
      }
    }

    function tokenize(prompt) {
      const ids = prompt.split(' ').map((_, i) => i + 1);
      return new ort.Tensor('int64',
        BigInt64Array.from(ids.map(BigInt)),
        [1, ids.length]);
    }

    function detokenize(tensor) {
      return 'Once upon a time, ' +
             tensor.data.join(' ') +
             '... (placeholder story)';
    }

    async function generateStory() {
      const p = document.getElementById('prompt').value.trim();
      if (!p) {
        alert('Please enter a prompt or click Random Story.');
        return;
      }
      await runInference(p);
    }

    async function generateRandomStory() {
      const pool = [
        'A curious fox in a glowing forest',
        'A tiny dragon who lost its fire',
        'A bunny exploring a starry meadow',
        'A magical treehouse adventure',
        'A friendly ghost in a cozy village'
      ];
      const p = pool[Math.floor(Math.random() * pool.length)];
      document.getElementById('prompt').value = p;
      await runInference(p);
    }

    async function runInference(prompt) {
      const storyDiv = document.getElementById('story');
      const loadDiv  = document.getElementById('loading');
      storyDiv.innerHTML = '';
      loadDiv.style.display = 'block';

      try {
        if (!session) {
          await initModel();
          if (!session) throw new Error('Model init failed');
        }

        // --- tokenize + mask ---
        const inputTensor = tokenize(prompt);
        const seqLen = inputTensor.dims[1];
        const maskArr = Array(seqLen).fill(1).map(BigInt);
        const attentionMask = new ort.Tensor(
          'int64',
          BigInt64Array.from(maskArr),
          [1, seqLen]
        );

        // --- basic feeds ---
        const feeds = {
          input_ids:      inputTensor,
          attention_mask: attentionMask
        };

        // --- build name→meta map ---
        const metaMap = session.inputMetadata.reduce((m, v) => {
          m[v.name] = v;
          return m;
        }, {});

        // --- zero‐fill all past_key_values.* ---
        for (let name of session.inputNames) {
          if (name.startsWith('past_key_values')) {
            const meta = metaMap[name];
            if (!meta) {
              console.warn(`No metadata for ${name}, skipping.`);
              continue;
            }
            // meta.shape is (string|number)[]
            const dims = meta.shape.map(d =>
              typeof d === 'number' ? d : 0
            );
            const size = dims.reduce((a, b) => a * b, 1);
            feeds[name] = new ort.Tensor(
              'float32',
              new Float32Array(size),
              dims
            );
          }
        }

        // --- run and decode ---
        const outputMap = await session.run(feeds);
        // adjust 'output' if your model names it differently
        const outTensor = outputMap.output;
        const text = detokenize(outTensor);

        loadDiv.style.display = 'none';
        storyDiv.innerHTML = `<p>${text}</p>`;
      } catch (err) {
        loadDiv.style.display = 'none';
        storyDiv.innerHTML =
          '<p>Oops, something went wrong. Check console.</p>';
        console.error('Inference error:', err);
      }
    }

    // preload model
    initModel();
  </script>
</body>
</html>
