<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>TinyStories Bedtime Generator</title>

  <!-- ONNX Runtime Web from CDN -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <script>
    // Point ORT to its WASM runners on the CDN
    ort.env.wasm.wasmPaths = {
      "ort-wasm.wasm":               "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort-wasm.wasm",
      "ort-wasm-simd.wasm":          "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort-wasm-simd.wasm",
      "ort-wasm-threaded.wasm":      "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort-wasm-threaded.wasm",
      "ort-wasm-simd-threaded.wasm": "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort-wasm-simd-threaded.wasm"
    };
  </script>

  <style>
    body { font-family: sans-serif; max-width: 600px; margin: 2em auto; line-height: 1.5; }
    textarea { width: 100%; box-sizing: border-box; font-size: 1em; }
    button { margin-top: .5em; margin-right: .5em; padding: .5em 1em; font-size: 1em; }
    pre { background: #f4f4f4; padding: 1em; white-space: pre-wrap; }
  </style>
</head>

<body>
  <h1>üõèÔ∏è TinyStories Bedtime Generator</h1>
  
  <textarea id="prompt" rows="4" placeholder="Once upon a time‚Ä¶"></textarea><br>
  <button id="generate">Generate Story</button>
  <button id="random">Random Story</button>
  
  <pre id="story"></pre>

  <script>
  // 1) Load your ONNX model (with past_key_values)
  const sessionPromise = ort.InferenceSession.create(
    "./models/TinyStories-Instruct-1M/TinyStories-Instruct-1M.onnx",
    { executionProviders: ["wasm"] }
  );

  // 2) Some default prompts for Random Story
  const DEFAULT_PROMPTS = [
    "A brave little snail goes on an adventure",
    "A friendly dragon who loves cookies",
    "A lost kitten in a magical forest",
    "A spaceship that tells bedtime stories",
    "A curious cloud exploring the sky"
  ];

  async function generateStory(promptText, maxNewTokens = 128) {
    const session = await sessionPromise;
    const encoder = new TextEncoder();
    const decoder = new TextDecoder();

    // Tokenize prompt
    let inputIds      = Array.from(encoder.encode(promptText));
    let attentionMask = Array(inputIds.length).fill(1);

    // Build position_ids = [0,1,...,L-1]
    let positionIds     = inputIds.map((_, i) => i);
    let currentPosition = positionIds.length;

    // Prepare empty cache feeds for past_key_values:
    // model config: hidden_size=64, num_heads=16 ‚Üí head_dim=4
    const cacheNames = session.inputNames.filter(n => n.startsWith("past_key_values."));
    const pastFeeds  = {};
    for (let name of cacheNames) {
      pastFeeds[name] = new ort.Tensor(
        "float32",
        new Float32Array(0),
        [1, 16, 4, 0]
      );
    }

    const generatedIds = [];

    for (let step = 0; step < maxNewTokens; step++) {
      // assemble feeds
      const feeds = {
        input_ids:      new ort.Tensor("int32", Int32Array.from(inputIds),       [1, inputIds.length]),
        attention_mask: new ort.Tensor("int32", Int32Array.from(attentionMask),  [1, attentionMask.length]),
        position_ids:   new ort.Tensor("int32", Int32Array.from(positionIds),    [1, positionIds.length]),
        ...pastFeeds
      };

      // run one autoregressive step
      const outputs = await session.run(feeds);

      // greedy decode
      const logits = outputs.logits.data;
      let maxLogit = -Infinity, nextId = 0;
      for (let i = 0; i < logits.length; i++) {
        if (logits[i] > maxLogit) {
          maxLogit = logits[i];
          nextId = i;
        }
      }
      generatedIds.push(nextId);

      // prepare for next step
      inputIds = [ nextId ];
      attentionMask = [ 1 ];
      positionIds = [ currentPosition ];
      currentPosition++;

      // swap in new cache values
      for (let k in outputs) {
        if (k.startsWith("present_key_values.")) {
          const pastName = k.replace("present_key_values", "past_key_values");
          pastFeeds[pastName] = outputs[k];
        }
      }

      // optionally break on EOS id (if you know it)
    }

    // return generated text
    return decoder.decode(new Uint8Array(generatedIds));
  }

  // wire up the buttons
  document.getElementById("generate").onclick = async () => {
    const prompt = document.getElementById("prompt").value.trim() || "Once upon a time";
    document.getElementById("story").textContent = "‚è≥ Generating‚Ä¶";
    const tale = await generateStory(prompt);
    document.getElementById("story").textContent = prompt + tale;
  };

  document.getElementById("random").onclick = () => {
    const idx = Math.floor(Math.random() * DEFAULT_PROMPTS.length);
    document.getElementById("prompt").value = DEFAULT_PROMPTS[idx];
    document.getElementById("generate").click();
  };
  </script>
</body>
</html>
